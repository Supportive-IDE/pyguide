import { 
    Diagnostic, Range, DiagnosticSeverity, TextDocument, DiagnosticCollection, 
    ExtensionContext, window, workspace, CodeActionProvider, CodeActionKind, 
    Selection, CodeActionContext, CancellationToken, CodeAction, env, Uri,
    Position, TextDocumentContentChangeEvent
} from 'vscode';
const sideLib = require('./lib/side-lib.es.js');
import { Feedback, SideLibResult } from './types';
import { EXTENSION_ID, EventTypes, SHOW_EXTERNAL_FEEDBACK, createCommand, errorIndicators } from './utils';
import { Logger } from './logging';

// Stores the parameters associated with each diagnostic
const paramsMap = new Map<string, string>();

/**
 * Gets all feedback instances from SIDE-lib and creates diagnostics. 
 * This demo diagnostic problem provider finds all mentions of 'emoji'.
 * @param doc text document to analyze
 * @param sideDiagnostics diagnostic collection
 * @param logger the Logger
 */
export function refreshDiagnostics(doc: TextDocument, 
    sideDiagnostics: DiagnosticCollection, 
    logger: Logger, 
    changes: readonly TextDocumentContentChangeEvent[] = [], 
    eventType: EventTypes | undefined = undefined): void {
    if (doc.languageId === 'python') {
        // set up
        const diagnostics: Diagnostic[] = [];
        paramsMap.clear();

        // Check for misconceptions and feedback 
        const result: SideLibResult = sideLib.feedback(doc.getText(), true);

        // Log all results
        sendToLog(doc, result, logger, changes, eventType);
        // Update the diagnostics
        for (const feedback of result.feedback) {
            const diagnostic = createDiagnostic(feedback, doc.positionAt(feedback.docIndex), doc.positionAt(feedback.docIndex + feedback.affectedText.length), doc.fileName);
            diagnostics.push(diagnostic);
        }

        sideDiagnostics.set(doc.uri, diagnostics);
    }
}


/**
 * Attempt to log the latest event
 * @param doc The open file in the editor
 * @param result Object returned from SIDE-lib
 * @param logger The logging controller
 * @param changes All changes in the doc
 * @param eventType The type of event
 */
function sendToLog(doc: TextDocument, result: SideLibResult, logger: Logger, changes: readonly TextDocumentContentChangeEvent[] = [], eventType: EventTypes | undefined = undefined) {
    try {
        logger.log(doc, changes, result, eventType);
    } catch (error) {
        console.log("LOGGING ERROR", error);
    }
}

/**
 * Create a diagnostic for a feedback instance
 * @param feedback The feedback object
 * @param start The start Position of the affected text
 * @param end The end Position of the affected text
 * @returns A VSCode Diagnostic
 */
function createDiagnostic(feedback: Feedback, start: Position, end: Position, docName: string) {
    const range = new Range(start, end);
    const message = feedback.firstMessage;
    const severity = errorIndicators.has(feedback.type) ? DiagnosticSeverity.Error : DiagnosticSeverity.Information;
    const diagnostic = new Diagnostic(
        range, message, severity 
    );
    diagnostic.source = EXTENSION_ID;
    const code = `${feedback.type}-${feedback.docIndex}`;
    diagnostic.code = {
        value: code,
        target: Uri.parse(`command:${createCommand(SHOW_EXTERNAL_FEEDBACK)}?${encodeURIComponent(JSON.stringify([{msg: feedback.extendedFeedbackParams, fileName: docName}]))}`)
    };
    paramsMap.set(code, feedback.extendedFeedbackParams);
    return diagnostic;
}

/**
 * Listens for document changes and trigger a refresh of the diagnostics
 * @param context the extension context
 * @param sideDiagnostics the diagnostics generated by SIDE-lib
 * @param logger the Logger
 */
export function subscribeToDocumentChanges(context: ExtensionContext, sideDiagnostics: DiagnosticCollection, logger: Logger): void {
	if (window.activeTextEditor) {
        refreshDiagnostics(window.activeTextEditor.document, 
                           sideDiagnostics, 
                           logger);
	}
	context.subscriptions.push(
		window.onDidChangeActiveTextEditor(editor => {
			if (editor) {
                refreshDiagnostics(editor.document, sideDiagnostics, logger);
			}
		})
	);

	context.subscriptions.push(
		workspace.onDidChangeTextDocument(e => {
            refreshDiagnostics(e.document, sideDiagnostics, logger, e.contentChanges); // Done
}       )
	);

	context.subscriptions.push(
		workspace.onDidCloseTextDocument(doc => {
            sideDiagnostics.delete(doc.uri);
            refreshDiagnostics(doc, sideDiagnostics, logger, [], EventTypes.close);
        })
	);

    context.subscriptions.push(
        workspace.onDidSaveTextDocument(doc => {
            refreshDiagnostics(doc, sideDiagnostics, logger, [], EventTypes.save);
        }),
    );
}

/**
 * Provides code actions corresponding to diagnostic problems.
 */
export class ExtendedGuidance implements CodeActionProvider {
    public static readonly providedCodeActionKinds = [
		CodeActionKind.Empty
	];

	provideCodeActions(_document: TextDocument, _range: Range | Selection, context: CodeActionContext, _token: CancellationToken): CodeAction[] {
		return context.diagnostics.map(diagnostic => this.createCommandCodeAction(diagnostic, _document.fileName));
	}

    private isPunctuation(lastChar: string) {
        return lastChar === '.' || lastChar === '!' || lastChar === '?';
    }

	private createCommandCodeAction(diagnostic: Diagnostic, docName: string): CodeAction {
        const action = new CodeAction(`${this.isPunctuation(diagnostic.message.charAt(diagnostic.message.length - 1)) ? diagnostic.message : diagnostic.message + "." } Learn more...`, CodeActionKind.Empty);
		const code = diagnostic.code as { value: string; target: Uri; };
        const msg = code ? paramsMap.get(code.value) : "";
        if (msg) {
            action.command = { command: createCommand(SHOW_EXTERNAL_FEEDBACK), title: `Learn more...`, tooltip: 'Open extended guidance.', arguments: [{msg: msg + "&TEST=TEST", fileName: docName}] };
            action.diagnostics = [diagnostic];
            action.isPreferred = true;
        }
        return action;
	}
}